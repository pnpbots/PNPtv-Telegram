        keyboard = [
            [InlineKeyboardButton("üí≥ Pay Securely with Bold.co", url=payment_url)],
            [InlineKeyboardButton("üîÑ Choose Different Plan", callback_data="show_plans")],
            [InlineKeyboardButton(TEXTS[lang]["back"], callback_data="main_menu")]
        ]
        
        await query.edit_message_text(
            text=text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
        
        # Log de selecci√≥n de plan para analytics
        logger.info(f"Usuario {user_id} seleccion√≥ plan {plan_info['name']} ({plan_info['price']})")
        
    except Exception as e:
        logger.error(f"Error en selecci√≥n de plan para {user_id}: {e}")
        await query.edit_message_text(
            "‚ùå Error procesando selecci√≥n de plan.\n"
            "Por favor intenta de nuevo o contacta soporte."
        )

async def show_subscription_status(query, user_id, data):
    """Mostrar estado de suscripci√≥n con informaci√≥n detallada"""
    try:
        manager = await get_subscriber_manager()
        user_status = await manager.get_user_status(user_id)
        lang = user_status.get('language', 'en')
        
        status = user_status['status']
        
        # Emojis y textos por estado
        status_info = {
            'active': ('‚úÖ', 'Active Subscription', 'üé¨ Enjoying premium content!'),
            'churned': ('‚ö†Ô∏è', 'Expired Subscription', 'üí° Renew to regain access!'), 
            'never': ('‚ùå', 'No Subscription', 'üöÄ Ready to start your journey?')
        }
        
        emoji, status_text, action_text = status_info.get(status, ('‚ùì', 'Unknown Status', ''))
        
        if status == 'active' and user_status['subscription']:
            sub = user_status['subscription']
            expires_at = sub['expires_at']
            
            # Calcular d√≠as restantes
            from datetime import datetime, timezone
            days_remaining = (expires_at - datetime.now(timezone.utc)).days
            
            # Obtener informaci√≥n de canales activos
            active_channels = [ch for ch in user_status['channel_access'] if ch['revoked_at'] is None]
            
            # Informaci√≥n de facturaci√≥n
            billing_info = ""
            if sub.get('payment_amount'):
                billing_info = f"\nüí∞ **Amount paid:** ${sub['payment_amount']:.2f} USD"
            if sub.get('transaction_id'):
                billing_info += f"\nüßæ **Transaction:** {sub['transaction_id'][:20]}..."
            
            text = f"""üìä **Your Subscription Status**

{emoji} **Status:** {status_text}
üíé **Plan:** {sub['plan']}
üìÖ **Started:** {sub['start_date'].strftime('%Y-%m-%d')}
‚è∞ **Expires:** {expires_at.strftime('%Y-%m-%d %H:%M')} UTC
‚è≥ **Days remaining:** {days_remaining} days

üì∫ **Active channels:** {len(active_channels)}
{billing_info}

{action_text}

üí° **Tip:** Renew before expiration to avoid service interruption."""

            keyboard = [
                [InlineKeyboardButton("üîÑ Renew Subscription", callback_data="show_plans")],
                [InlineKeyboardButton("üìß Contact Support", callback_data="contact")]
            ]
            
        elif status == 'churned' and user_status['subscription']:
            sub = user_status['subscription']
            expired_date = sub['expires_at']
            
            # Calcular d√≠as desde expiraci√≥n
            days_expired = (datetime.now(timezone.utc) - expired_date).days
            
            text = f"""üìä **Your Subscription Status**

{emoji} **Status:** {status_text}
üíé **Previous plan:** {sub['plan']}
üìÖ **Expired:** {expired_date.strftime('%Y-%m-%d %H:%M')} UTC
‚è≥ **Days ago:** {days_expired} days

‚ùå **Channel access:** Revoked
üìû **Support:** Available 24/7

{action_text}

üéØ **Special offer:** Check our plans for returning customers!"""

            keyboard = [
                [InlineKeyboardButton("üíé View Plans", callback_data="show_plans")],
                [InlineKeyboardButton("üìß Contact Support", callback_data="contact")]
            ]
            
        else:  # never subscribed
            text = f"""üìä **Your Subscription Status**

{emoji} **Status:** {status_text}
üìÖ **Member since:** {user_status.get('last_seen', datetime.now()).strftime('%Y-%m-%d')}
üåê **Language:** {lang.upper()}

{action_text}

üé¨ **What you're missing:**
‚Ä¢ 200+ exclusive premium videos
‚Ä¢ Multiple premium channels  
‚Ä¢ Virtual events and live content
‚Ä¢ Priority customer support

üí∞ **Plans starting at just $14.99!**"""

            keyboard = [
                [InlineKeyboardButton("üíé View Subscription Plans", callback_data="show_plans")],
                [InlineKeyboardButton("‚ùì Learn More", callback_data="help")]
            ]
        
        keyboard.append([InlineKeyboardButton(TEXTS[lang]["back"], callback_data="main_menu")])
        
        await query.edit_message_text(
            text=text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Error verificando estado de suscripci√≥n para {user_id}: {e}")
        await query.edit_message_text(
            "‚ùå Error verificando estado de suscripci√≥n.\n"
            "Por favor intenta de nuevo."
        )

async def show_policies(query, user_id, data):
    """Men√∫ de pol√≠ticas mejorado"""
    try:
        manager = await get_subscriber_manager()
        user_status = await manager.get_user_status(user_id)
        lang = user_status.get('language', 'en')
        
        keyboard = [
            [InlineKeyboardButton(TEXTS[lang]["terms_label"], callback_data="terms")],
            [InlineKeyboardButton(TEXTS[lang]["privacy_label"], callback_data="privacy")],
            [InlineKeyboardButton(TEXTS[lang]["refund_label"], callback_data="refund")],
            [InlineKeyboardButton("üìû Contact Legal", callback_data="contact")],
            [InlineKeyboardButton(TEXTS[lang]["back"], callback_data="main_menu")]
        ]
        
        policy_text = TEXTS[lang]["policies_menu"]
        additional_info = "\n\nüìã **Legal Information:**\n" \
                         "‚Ä¢ Terms updated: December 2024\n" \
                         "‚Ä¢ GDPR compliant\n" \
                         "‚Ä¢ Adult content service\n" \
                         "‚Ä¢ Secure payment processing"
        
        await query.edit_message_text(
            text=policy_text + additional_info,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Error mostrando pol√≠ticas para {user_id}: {e}")
        await query.edit_message_text("‚ùå Error cargando pol√≠ticas.")

async def show_terms(query, user_id, data):
    """T√©rminos y condiciones completos"""
    try:
        manager = await get_subscriber_manager()
        user_status = await manager.get_user_status(user_id)
        lang = user_status.get('language', 'en')
        
        keyboard = [
            [InlineKeyboardButton("üìß Legal Questions", callback_data="contact")],
            [InlineKeyboardButton(TEXTS[lang]["back"], callback_data="policies")]
        ]
        
        terms_text = TEXTS[lang]["terms_content"]
        
        # Agregar informaci√≥n adicional
        additional_terms = "\n\n**üìÖ Last Updated:** December 2024\n" \
                          "**‚öñÔ∏è Jurisdiction:** International\n" \
                          "**üìß Legal Contact:** legal@pnptv.app"
        
        full_text = terms_text + additional_terms
        
        # Verificar l√≠mite de caracteres de Telegram
        if len(full_text) > 4096:
            full_text = terms_text[:4000] + "\n\n[...continued on website...]" + additional_terms
        
        await query.edit_message_text(
            text=full_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Error mostrando t√©rminos para {user_id}: {e}")
        await query.edit_message_text("‚ùå Error cargando t√©rminos.")

async def show_privacy(query, user_id, data):
    """Pol√≠tica de privacidad detallada"""
    try:
        manager = await get_subscriber_manager()
        user_status = await manager.get_user_status(user_id)
        lang = user_status.get('language', 'en')
        
        keyboard = [
            [InlineKeyboardButton("üóëÔ∏è Delete My Data", callback_data="delete_data_request")],
            [InlineKeyboardButton("üìß Privacy Questions", callback_data="contact")],
            [InlineKeyboardButton(TEXTS[lang]["back"], callback_data="policies")]
        ]
        
        privacy_text = TEXTS[lang]["privacy_content"]
        
        # Agregar informaci√≥n espec√≠fica
        gdpr_info = "\n\n**üîê Your Privacy Rights:**\n" \
                   "‚Ä¢ Right to access your data\n" \
                   "‚Ä¢ Right to rectification\n" \
                   "‚Ä¢ Right to erasure\n" \
                   "‚Ä¢ Right to data portability\n\n" \
                   "**üìß Privacy Officer:** privacy@pnptv.app"
        
        full_text = privacy_text + gdpr_info
        
        await query.edit_message_text(
            text=full_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Error mostrando privacidad para {user_id}: {e}")
        await query.edit_message_text("‚ùå Error cargando pol√≠tica de privacidad.")

async def show_refund(query, user_id, data):
    """Pol√≠tica de reembolsos clara"""
    try:
        manager = await get_subscriber_manager()
        user_status = await manager.get_user_status(user_id)
        lang = user_status.get('language', 'en')
        
        keyboard = [
            [InlineKeyboardButton("üí¨ Request Refund", callback_data="contact")],
            [InlineKeyboardButton("‚ùì Refund Questions", callback_data="contact")],
            [InlineKeyboardButton(TEXTS[lang]["back"], callback_data="policies")]
        ]
        
        refund_text = TEXTS[lang]["refund_content"]
        
        # Agregar proceso detallado
        process_info = "\n\n**üìã Refund Process:**\n" \
                      "1. Contact support within 48 hours\n" \
                      "2. Provide transaction ID\n" \
                      "3. Explain technical issue\n" \
                      "4. Wait 3-5 business days for review\n\n" \
                      "**‚è±Ô∏è Processing Time:** 5-7 business days\n" \
                      "**üí≥ Refund Method:** Original payment method"
        
        full_text = refund_text + process_info
        
        await query.edit_message_text(
            text=full_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Error mostrando reembolsos para {user_id}: {e}")
        await query.edit_message_text("‚ùå Error cargando pol√≠tica de reembolsos.")

async def show_contact(query, user_id, data):
    """Informaci√≥n de contacto completa"""
    try:
        manager = await get_subscriber_manager()
        user_status = await manager.get_user_status(user_id)
        lang = user_status.get('language', 'en')
        
        if lang == 'es':
            contact_text = """üìû **Informaci√≥n de Contacto**

**üìß Email Principal:** support@pnptv.app
**‚ö° Email Urgencias:** urgent@pnptv.app
**‚öñÔ∏è Email Legal:** legal@pnptv.app

**üïê Horarios de Atenci√≥n:**
‚Ä¢ Lunes - Viernes: 9:00 AM - 6:00 PM EST
‚Ä¢ S√°bado - Domingo: 12:00 PM - 4:00 PM EST
‚Ä¢ Urgencias: 24/7 (email √∫nicamente)

**üì± C√≥mo obtener ayuda:**
1. Env√≠a cualquier mensaje a este bot
2. Incluye tu ID de usuario: `{user_id}`
3. Describe tu problema claramente
4. Adjunta capturas si es necesario

**üö® Para Emergencias:**
‚Ä¢ Problemas de facturaci√≥n: urgent@pnptv.app
‚Ä¢ Acceso bloqueado: support@pnptv.app
‚Ä¢ Problemas legales: legal@pnptv.app

**‚è±Ô∏è Tiempo de Respuesta:**
‚Ä¢ Consultas generales: 24-48 horas
‚Ä¢ Problemas t√©cnicos: 12-24 horas
‚Ä¢ Emergencias: 2-6 horas

¬°Estamos aqu√≠ para ayudarte! üé¨"""
        else:
            contact_text = f"""üìû **Contact Information**

**üìß Main Support:** support@pnptv.app
**‚ö° Urgent Issues:** urgent@pnptv.app
**‚öñÔ∏è Legal Matters:** legal@pnptv.app

**üïê Business Hours:**
‚Ä¢ Monday - Friday: 9:00 AM - 6:00 PM EST
‚Ä¢ Saturday - Sunday: 12:00 PM - 4:00 PM EST
‚Ä¢ Emergencies: 24/7 (email only)

**üì± How to get help:**
1. Send any message to this bot
2. Include your user ID: `{user_id}`
3. Describe your issue clearly
4. Attach screenshots if needed

**üö® For Emergencies:**
‚Ä¢ Billing issues: urgent@pnptv.app
‚Ä¢ Access problems: support@pnptv.app
‚Ä¢ Legal concerns: legal@pnptv.app

**‚è±Ô∏è Response Time:**
‚Ä¢ General inquiries: 24-48 hours
‚Ä¢ Technical issues: 12-24 hours
‚Ä¢ Emergencies: 2-6 hours

We're here to help! üé¨"""
        
        keyboard = [
            [InlineKeyboardButton("üìß Send Support Email", url="mailto:support@pnptv.app")],
            [InlineKeyboardButton("‚ö° Urgent Support", url="mailto:urgent@pnptv.app")],
            [InlineKeyboardButton(TEXTS[lang]["back"], callback_data="main_menu")]
        ]
        
        await query.edit_message_text(
            text=contact_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Error mostrando contacto para {user_id}: {e}")
        await query.edit_message_text("‚ùå Error cargando informaci√≥n de contacto.")

async def show_help(query, user_id, data):
    """Sistema de ayuda completo"""
    try:
        manager = await get_subscriber_manager()
        user_status = await manager.get_user_status(user_id)
        lang = user_status.get('language', 'en')
        
        if lang == 'es':
            help_text = f"""üé¨ **Centro de Ayuda PNP Television**

**ü§ñ Comandos Disponibles:**
‚Ä¢ `/start` - Reiniciar el bot y seleccionar idioma
‚Ä¢ `/help` - Mostrar esta ayuda
‚Ä¢ `/plans` - Ver planes de suscripci√≥n
‚Ä¢ `/status` - Verificar estado de suscripci√≥n

**üí° Preguntas Frecuentes:**

**üîê ¬øC√≥mo suscribirse?**
1. Usa /plans para ver opciones
2. Selecciona tu plan preferido
3. Completa el pago seguro via Bold.co
4. ¬°Acceso instant√°neo a tu contenido!

**üì± ¬øProblemas de acceso?**
‚Ä¢ Verifica que tengas suscripci√≥n activa
‚Ä¢ Revisa los enlaces de invitaci√≥n
‚Ä¢ Contacta soporte si persiste

**üí≥ ¬øProblemas de pago?**
‚Ä¢ Todos los pagos via Bold.co (seguro)
‚Ä¢ Soporte de tarjetas internacionales
‚Ä¢ Confirmaci√≥n instant√°nea

**üîÑ ¬øC√≥mo renovar?**
‚Ä¢ Usa /plans antes del vencimiento
‚Ä¢ La renovaci√≥n extiende tu acceso actual
‚Ä¢ Sin interrupciones en el servicio

**üìß ¬øNecesitas m√°s ayuda?**
¬°Env√≠a cualquier mensaje a este bot y nuestro equipo te contactar√°!

**üÜî Tu ID de usuario:** `{user_id}`
(Incluye este ID al contactar soporte)"""
        else:
            help_text = f"""üé¨ **PNP Television Help Center**

**ü§ñ Available Commands:**
‚Ä¢ `/start` - Restart bot and select language
‚Ä¢ `/help` - Show this help
‚Ä¢ `/plans` - View subscription plans
‚Ä¢ `/status` - Check subscription status

**üí° Frequently Asked Questions:**

**üîê How to Subscribe?**
1. Use /plans to see options
2. Choose your preferred plan
3. Complete secure payment via Bold.co
4. Get instant access to content!

**üì± Access Problems?**
‚Ä¢ Verify you have active subscription
‚Ä¢ Check invitation links in messages
‚Ä¢ Contact support if issues persist

**üí≥ Payment Issues?**
‚Ä¢ All payments via Bold.co (secure)
‚Ä¢ International cards supported
‚Ä¢ Instant confirmation

**üîÑ How to Renew?**
‚Ä¢ Use /plans before expiration
‚Ä¢ Renewal extends your current access
‚Ä¢ No service interruptions

**üìß Need More Help?**
Send any message to this bot and our team will contact you!

**üÜî Your User ID:** `{user_id}`
(Include this ID when contacting support)"""
        
        keyboard = [
            [InlineKeyboardButton("üíé View Plans", callback_data="show_plans")],
            [InlineKeyboardButton("üìä Check Status", callback_data="subscription_status")],
            [InlineKeyboardButton("üìû Contact Support", callback_data="contact")],
            [InlineKeyboardButton(TEXTS[lang]["back"], callback_data="main_menu")]
        ]
        
        await query.edit_message_text(
            text=help_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Error mostrando ayuda para {user_id}: {e}")
        await query.edit_message_text("‚ùå Error cargando centro de ayuda.")

# Funciones para el panel de administraci√≥n

async def show_admin_menu(query, user_id, data):
    """Men√∫ principal de administraci√≥n"""
    if user_id not in ADMIN_IDS:
        await query.edit_message_text("‚õî Unauthorized access")
        return
    
    try:
        manager = await get_subscriber_manager()
        stats = await manager.get_stats()
        
        keyboard = [
            [InlineKeyboardButton("üìä Detailed Statistics", callback_data="admin_stats")],
            [InlineKeyboardButton("üë• User Management", callback_data="admin_users")],
            [InlineKeyboardButton("üì¢ Broadcast System", callback_data="admin_broadcast")],
            [InlineKeyboardButton("üìà Metrics Dashboard", callback_data="admin_metrics")],
            [InlineKeyboardButton("üåê Web Panel", url=f"http://{ADMIN_HOST}:{ADMIN_PORT}")],
            [InlineKeyboardButton("üîô Main Menu", callback_data="main_menu")]
        ]
        
        text = f"""üîß **Admin Control Panel**

**üìä Quick Overview:**
üë• Total Users: {stats['total']}
‚úÖ Active Subscriptions: {stats['active']}
üí∞ Active Revenue: ${stats.get('active_revenue', 0):.2f}
üìß Total Revenue: ${stats.get('total_revenue', 0):.2f}

**üéØ Conversion Rate:** {(stats['active']/max(stats['total'], 1)*100):.1f}%

Select an option to continue:"""
        
        await query.edit_message_text(
            text=text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Error showing admin menu: {e}")
        await query.edit_message_text("‚ùå Error accessing admin panel")

async def show_admin_stats(query, user_id, data):
    """Estad√≠sticas detalladas para administradores"""
    if user_id not in ADMIN_IDS:
        await query.edit_message_text("‚õî Unauthorized access")
        return
    
    try:
        manager = await get_subscriber_manager()
        stats = await manager.get_stats()
        metrics = manager.get_metrics()

        # Construir breakdown por planes
        plan_text = ""
        for plan, data in stats.get('plans', {}).items():
            plan_text += f"‚Ä¢ {plan}: {data['count']} users (${data['revenue']:.2f})\n"

        # Construir breakdown por idiomas
        lang_text = ""
        for lang, count in stats.get('languages', {}).items():
            flag = "üá∫üá∏" if lang == "en" else "üá™üá∏" if lang == "es" else "üåç"
            percentage = (count / max(stats['total'], 1) * 100)
            lang_text += f"{flag} {lang.upper()}: {count} ({percentage:.1f}%)\n"

        text = f"""üìä **Comprehensive Statistics**

**üë• User Metrics:**
‚Ä¢ Total Users: {stats['total']}
‚Ä¢ Active Subscriptions: {stats['active']}
‚Ä¢ Expired Subscriptions: {stats['churned']}
‚Ä¢ Never Subscribed: {stats['never']}

**üí∞ Revenue Metrics:**
‚Ä¢ Active MRR: ${stats.get('active_revenue', 0):.2f}
‚Ä¢ Total Revenue: ${stats.get('total_revenue', 0):.2f}
‚Ä¢ Conversion Rate: {(stats['active']/max(stats['total'], 1)*100):.1f}%

**üìà Performance:**
‚Ä¢ Invites Sent: {metrics.get('invites_sent', 0)}
‚Ä¢ Success Rate: {((metrics.get('invites_sent', 1) - metrics.get('invites_failed', 0)) / max(metrics.get('invites_sent', 1), 1) * 100):.1f}%
‚Ä¢ Payments: {metrics.get('payments_processed', 0)}
‚Ä¢ Reminders: {metrics.get('reminders_sent', 0)}

**üéØ Active Plans:**
{plan_text or 'No active subscriptions'}

**üåç Languages:**
{lang_text or 'No users'}

**üìÖ Updated:** {datetime.now().strftime('%H:%M:%S')} UTC"""

        keyboard = [
            [InlineKeyboardButton("üîÑ Refresh", callback_data="admin_stats")],
            [InlineKeyboardButton("üìä Export Data", callback_data="admin_export")],
            [InlineKeyboardButton("üîô Admin Menu", callback_data="admin_menu")]
        ]

        await query.edit_message_text(
            text=text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Error showing admin stats: {e}")
        await query.edit_message_text("‚ùå Error retrieving statistics")

async def show_admin_users(query, user_id, data):
    """Panel de gesti√≥n de usuarios"""
    if user_id not in ADMIN_IDS:
        await query.edit_message_text("‚õî Unauthorized access")
        return
    
    keyboard = [
        [InlineKeyboardButton("üë• All Users", callback_data="admin_list_all")],
        [InlineKeyboardButton("‚úÖ Active Subs", callback_data="admin_list_active")],
        [InlineKeyboardButton("‚ö†Ô∏è Expired Subs", callback_data="admin_list_churned")],
        [InlineKeyboardButton("‚ùå Never Subscribed", callback_data="admin_list_never")],
        [InlineKeyboardButton("üîç Search User", callback_data="admin_search_user")],
        [InlineKeyboardButton("üîô Admin Menu", callback_data="admin_menu")]
    ]
    
    text = """üë• **User Management Panel**

Select an option to manage users:

‚Ä¢ **All Users** - View complete user list
‚Ä¢ **Active Subs** - Users with active subscriptions
‚Ä¢ **Expired Subs** - Users with expired subscriptions  
‚Ä¢ **Never Subscribed** - Users who never purchased
‚Ä¢ **Search User** - Find specific user by ID

Use the web panel for bulk operations and detailed management."""
    
    await query.edit_message_text(
        text=text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='Markdown'
    )

async def show_admin_broadcast(query, user_id, data):
    """Panel de sistema de broadcast"""
    if user_id not in ADMIN_IDS:
        await query.edit_message_text("‚õî Unauthorized access")
        return
    
    keyboard = [
        [InlineKeyboardButton("üì¢ Start Broadcast", callback_data="admin_new_broadcast")],
        [InlineKeyboardButton("üìÖ Scheduled Messages", callback_data="admin_scheduled")],
        [InlineKeyboardButton("üìä Broadcast Stats", callback_data="admin_broadcast_stats")],
        [InlineKeyboardButton("üéØ Test Message", callback_data="admin_test_broadcast")],
        [InlineKeyboardButton("üîô Admin Menu", callback_data="admin_menu")]
    ]
    
    text = """üì¢ **Broadcast Management**

**Current Limits:**
‚Ä¢ Max 12 broadcasts per 24 hours
‚Ä¢ Scheduling up to 72 hours ahead
‚Ä¢ Multi-language support
‚Ä¢ User segmentation available

**Available Features:**
‚Ä¢ Text messages with Markdown
‚Ä¢ Photo broadcasts with captions
‚Ä¢ Video broadcasts with captions
‚Ä¢ GIF broadcasts with captions

**Targeting Options:**
‚Ä¢ All users
‚Ä¢ Active subscribers only
‚Ä¢ Expired subscriptions
‚Ä¢ Never purchased
‚Ä¢ Language filtering (EN/ES)

Use `/broadcast` command for interactive wizard or select option below:"""
    
    await query.edit_message_text(
        text=text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='Markdown'
    )

async def show_admin_metrics(query, user_id, data):
    """Dashboard de m√©tricas del sistema"""
    if user_id not in ADMIN_IDS:
        await query.edit_message_text("‚õî Unauthorized access")
        return
    
    try:
        manager = await get_subscriber_manager()
        stats = await manager.get_stats()
        metrics = manager.get_metrics()
        
        # Calcular m√©tricas avanzadas
        total_users = stats['total']
        active_users = stats['active']
        
        conversion_rate = (active_users / max(total_users, 1)) * 100
        
        # Calcular ARPU (Average Revenue Per User)
        total_revenue = stats.get('total_revenue', 0)
        arpu = total_revenue / max(total_users, 1)
        
        # Tasa de √©xito de invitaciones
        invites_sent = metrics.get('invites_sent', 0)
        invites_failed = metrics.get('invites_failed', 0)
        invite_success_rate = ((invites_sent - invites_failed) / max(invites_sent, 1)) * 100
        
        text = f"""üìà **Advanced Metrics Dashboard**

**üìä Key Performance Indicators:**
‚Ä¢ Conversion Rate: {conversion_rate:.2f}%
‚Ä¢ ARPU: ${arpu:.2f}
‚Ä¢ Active Users: {active_users}/{total_users}
‚Ä¢ Monthly Revenue: ${stats.get('active_revenue', 0):.2f}

**üéØ Operational Metrics:**
‚Ä¢ Invite Success Rate: {invite_success_rate:.1f}%
‚Ä¢ Invites Sent: {invites_sent}
‚Ä¢ Failed Invites: {invites_failed}
‚Ä¢ Payments Processed: {metrics.get('payments_processed', 0)}

**üìß Communication:**
‚Ä¢ Reminders Sent: {metrics.get('reminders_sent', 0)}
‚Ä¢ Support Requests: N/A
‚Ä¢ Response Rate: N/A

**üìÖ Performance Trends:**
{self._format_recent_activity(stats.get('recent_activity', []))}

**üéØ Recommendations:**
{self._generate_recommendations(stats, metrics)}

Data updated in real-time."""
        
        keyboard = [
            [InlineKeyboardButton("üîÑ Refresh Metrics", callback_data="admin_metrics")],
            [InlineKeyboardButton("üìä Detailed Stats", callback_data="admin_stats")],
            [InlineKeyboardButton("üåê Web Dashboard", url=f"http://{ADMIN_HOST}:{ADMIN_PORT}")],
            [InlineKeyboardButton("üîô Admin Menu", callback_data="admin_menu")]
        ]
        
        await query.edit_message_text(
            text=text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Error showing admin metrics: {e}")
        await query.edit_message_text("‚ùå Error loading metrics dashboard")

def _format_recent_activity(activity_data):
    """Formatear datos de actividad reciente"""
    if not activity_data:
        return "‚Ä¢ No recent activity data available"
    
    result = ""
    for entry in activity_data[:3]:  # √öltimos 3 d√≠as
        date = entry.get('date', 'Unknown')
        new_users = entry.get('new_users', 0)
        result += f"‚Ä¢ {date}: {new_users} new users\n"
    
    return result.rstrip('\n') or "‚Ä¢ No recent activity"

def _generate_recommendations(stats, metrics):
    """Generar recomendaciones basadas en m√©tricas"""
    recommendations = []
    
    # Analizar tasa de conversi√≥n
    conversion_rate = (stats['active'] / max(stats['total'], 1)) * 100
    if conversion_rate < 10:
        recommendations.append("Low conversion rate - consider promotional campaigns")
    elif conversion_rate > 30:
        recommendations.append("Excellent conversion rate - scale marketing efforts")
    
    # Analizar usuarios que nunca compraron
    never_bought = stats.get('never', 0)
    if never_bought > stats['active']:
        recommendations.append("Many users haven't purchased - send targeted offers")
    
    # Analizar tasa de √©xito de invitaciones
    invite_success = ((metrics.get('invites_sent', 1) - metrics.get('invites_failed', 0)) / max(metrics.get('invites_sent', 1), 1)) * 100
    if invite_success < 90:
        recommendations.append("Check channel permissions and bot admin status")
    
    return "\n".join(f"‚Ä¢ {rec}" for rec in recommendations[:3]) or "‚Ä¢ All metrics looking good!"

# Import adicional para datetime
from datetime import datetime# -*- coding: utf-8 -*-
"""
CALLBACKS MEJORADOS CON MANEJO DE ERRORES Y VALIDACIONES
=======================================================
Sistema completo con persistencia de estado y manejo robusto de errores
"""

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from telegram.error import TelegramError
import logging
from datetime import datetime
from bot.texts import TEXTS
from bot.config import PLANS, ADMIN_IDS, CHANNELS
from bot.enhanced_subscriber_manager import get_subscriber_manager  # ‚úÖ CORREGIDO: Import correcto

logger = logging.getLogger(__name__)

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler principal de callbacks con manejo robusto de errores"""
    query = update.callback_query
    
    try:
        await query.answer()
        
        data = query.data
        user_id = query.from_user.id
        
        logger.info(f"Callback received: {data} from user {user_id}")
        
        # Router completo de callbacks con validaci√≥n
        callback_handlers = {
            "lang_": handle_language_selection,
            "confirm_age": handle_age_confirmation,
            "decline_age": handle_age_decline,
            "accept_terms": handle_terms_acceptance,
            "decline_terms": handle_terms_decline,
            "main_menu": show_main_menu,
            "show_plans": show_plans,
            "policies": show_policies,
            "terms": show_terms,
            "privacy": show_privacy,
            "refund": show_refund,
            "contact": show_contact,
            "help": show_help,
            "admin_stats": show_admin_stats,
            "admin_menu": show_admin_menu,
            "admin_users": show_admin_users,
            "admin_broadcast": show_admin_broadcast,
            "admin_metrics": show_admin_metrics,
            "plan_": handle_plan_selection,
            "subscription_status": show_subscription_status,
        }
        
        # Buscar handler apropiado
        handler_found = False
        for prefix, handler in callback_handlers.items():
            if data.startswith(prefix) or data == prefix.rstrip("_"):
                await handler(query, user_id, data)
                handler_found = True
                break
        
        if not handler_found:
            logger.warning(f"Callback desconocido: {data} de usuario {user_id}")
            await query.edit_message_text(
                "‚ùå Esta funci√≥n no est√° disponible temporalmente.\n"
                "Usa /start para volver al men√∫ principal."
            )
            
    except TelegramError as e:
        logger.error(f"Error de Telegram en callback {query.data}: {e}")
        try:
            await query.edit_message_text(
                "‚ùå Error de conexi√≥n. Por favor intenta de nuevo.\n"
                "Si el problema persiste, usa /start"
            )
        except:
            # Si no puede editar el mensaje, enviar uno nuevo
            await context.bot.send_message(
                chat_id=query.from_user.id,
                text="‚ùå Error de conexi√≥n. Usa /start para continuar."
            )
    except Exception as e:
        logger.error(f"Error cr√≠tico en callback {query.data}: {e}")
        try:
            await query.edit_message_text(
                "‚ùå Error interno del sistema.\n"
                "El equipo t√©cnico ha sido notificado.\nUsa /start para continuar."
            )
        except:
            pass

async def handle_language_selection(query, user_id, data):
    """Selecci√≥n de idioma con validaci√≥n mejorada"""
    try:
        lang = data.split("_")[1]
        
        # Validar idioma
        if lang not in ['en', 'es']:
            logger.warning(f"Idioma inv√°lido seleccionado: {lang}")
            await query.edit_message_text("‚ùå Idioma no v√°lido. Usa /start para reiniciar.")
            return

        manager = await get_subscriber_manager()
        await manager.record_user(
            user_id, 
            language=lang,
            username=query.from_user.username,
            first_name=query.from_user.first_name,
            last_name=query.from_user.last_name
        )
        
        logger.info(f"Usuario {user_id} seleccion√≥ idioma: {lang}")
        await show_age_verification(query, user_id, lang)
        
    except Exception as e:
        logger.error(f"Error en selecci√≥n de idioma para {user_id}: {e}")
        await query.edit_message_text(
            "‚ùå Error guardando preferencia de idioma.\n"
            "Por favor intenta de nuevo con /start"
        )

async def show_age_verification(query, user_id, lang=None):
    """Verificaci√≥n de edad con recuperaci√≥n de estado"""
    if not lang:
        try:
            manager = await get_subscriber_manager()
            user_status = await manager.get_user_status(user_id)
            lang = user_status.get('language', 'en')
        except Exception as e:
            logger.error(f"Error obteniendo idioma para {user_id}: {e}")
            lang = 'en'
    
    keyboard = [
        [InlineKeyboardButton(TEXTS[lang]["confirm_age"], callback_data="confirm_age")],
        [InlineKeyboardButton(TEXTS[lang]["decline_age"], callback_data="decline_age")]
    ]
    
    try:
        await query.edit_message_text(
            text=TEXTS[lang]["age_warning"],
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
    except TelegramError as e:
        logger.error(f"Error mostrando verificaci√≥n de edad: {e}")
        await query.edit_message_text("‚ùå Error en el sistema. Usa /start para reiniciar.")

async def handle_age_confirmation(query, user_id, data):
    """Confirmaci√≥n de edad con persistencia mejorada"""
    try:
        manager = await get_subscriber_manager()
        await manager.record_user(user_id, age_verified=True)
        
        # Log de actividad de seguridad
        logger.info(f"Usuario {user_id} confirm√≥ verificaci√≥n de edad - IP: {query.from_user.id}")
        
        await show_terms_acceptance(query, user_id)
        
    except Exception as e:
        logger.error(f"Error guardando verificaci√≥n de edad para {user_id}: {e}")
        await query.edit_message_text(
            "‚ùå Error en verificaci√≥n. Por favor contacta soporte si persiste."
        )

async def handle_age_decline(query, user_id, data):
    """Manejar rechazo de edad con mensaje biling√ºe"""
    try:
        manager = await get_subscriber_manager()
        user_status = await manager.get_user_status(user_id)
        lang = user_status.get('language', 'en')
        
        if lang == 'es':
            message = "‚ùå Debes tener 18+ a√±os para usar este servicio.\n\n" \
                     "Este contenido est√° restringido a adultos mayores de edad."
        else:
            message = "‚ùå You must be 18+ to use this service.\n\n" \
                     "This content is restricted to adults only."
        
        await query.edit_message_text(message)
        
    except Exception as e:
        logger.error(f"Error en rechazo de edad: {e}")
        await query.edit_message_text(
            "‚ùå You must be 18+ to use this service.\n"
            "‚ùå Debes tener 18+ para usar este servicio."
        )

async def show_terms_acceptance(query, user_id):
    """Mostrar t√©rminos con formato mejorado"""
    try:
        manager = await get_subscriber_manager()
        user_status = await manager.get_user_status(user_id)
        lang = user_status.get('language', 'en')
        
        terms_text = TEXTS[lang]["terms_content"]
        
        # Agregar texto de aceptaci√≥n con formato
        if lang == 'es':
            acceptance_text = "\n\n‚ö†Ô∏è **IMPORTANTE:** Al continuar, aceptas nuestros t√©rminos y condiciones.\n\n" \
                            "**‚úÖ Acepto** - Continuar con el registro\n" \
                            "**‚ùå No acepto** - Salir del servicio"
            accept_button = "‚úÖ Acepto los t√©rminos"
            decline_button = "‚ùå No acepto"
        else:
            acceptance_text = "\n\n‚ö†Ô∏è **IMPORTANT:** By continuing, you accept our terms and conditions.\n\n" \
                            "**‚úÖ Accept** - Continue with registration\n" \
                            "**‚ùå Decline** - Exit service"
            accept_button = "‚úÖ I accept the terms"
            decline_button = "‚ùå I don't accept"
        
        keyboard = [
            [InlineKeyboardButton(accept_button, callback_data="accept_terms")],
            [InlineKeyboardButton(decline_button, callback_data="decline_terms")]
        ]
        
        # Truncar t√©rminos si son muy largos para Telegram
        full_text = terms_text + acceptance_text
        if len(full_text) > 4096:
            terms_text = terms_text[:3500] + "\n\n[...t√©rminos completos disponibles en el men√∫ principal...]"
            full_text = terms_text + acceptance_text
        
        await query.edit_message_text(
            text=full_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Error mostrando t√©rminos para {user_id}: {e}")
        await query.edit_message_text(
            "‚ùå Error cargando t√©rminos y condiciones.\n"
            "Por favor contacta soporte."
        )

async def handle_terms_acceptance(query, user_id, data):
    """Manejar aceptaci√≥n de t√©rminos con timestamp"""
    try:
        manager = await get_subscriber_manager()
        await manager.record_user(user_id, terms_accepted=True)
        
        # Log de aceptaci√≥n legal
        logger.info(f"Usuario {user_id} acept√≥ t√©rminos y condiciones - Timestamp: {datetime.now()}")
        
        await show_main_menu(query, user_id)
        
    except Exception as e:
        logger.error(f"Error guardando aceptaci√≥n de t√©rminos para {user_id}: {e}")
        await query.edit_message_text(
            "‚ùå Error procesando aceptaci√≥n.\n"
            "Por favor intenta de nuevo o contacta soporte."
        )

async def handle_terms_decline(query, user_id, data):
    """Manejar rechazo de t√©rminos"""
    try:
        manager = await get_subscriber_manager()
        user_status = await manager.get_user_status(user_id)
        lang = user_status.get('language', 'en')
        
        if lang == 'es':
            message = "‚ùå Debes aceptar los t√©rminos y condiciones para usar este servicio.\n\n" \
                     "Si tienes preguntas sobre nuestros t√©rminos, contacta: support@pnptv.app"
        else:
            message = "‚ùå You must accept the terms and conditions to use this service.\n\n" \
                     "If you have questions about our terms, contact: support@pnptv.app"
        
        await query.edit_message_text(message)
        
    except Exception as e:
        logger.error(f"Error en rechazo de t√©rminos: {e}")
        await query.edit_message_text(
            "‚ùå You must accept the terms and conditions to use this service.\n"
            "‚ùå Debes aceptar los t√©rminos y condiciones para usar este servicio."
        )

async def show_main_menu(query, user_id, data=None):
    """Men√∫ principal con verificaci√≥n completa de estado"""
    try:
        manager = await get_subscriber_manager()
        user_status = await manager.get_user_status(user_id)
        
        # Verificar progreso de verificaci√≥n
        if not user_status.get('age_verified', False):
            await show_age_verification(query, user_id, user_status.get('language', 'en'))
            return
        
        if not user_status.get('terms_accepted', False):
            await show_terms_acceptance(query, user_id)
            return
        
        lang = user_status.get('language', 'en')
        
        # Crear men√∫ contextual basado en estado de suscripci√≥n
        keyboard = [
            [InlineKeyboardButton(TEXTS[lang]["plans"], callback_data="show_plans")],
            [InlineKeyboardButton("üìä My Subscription", callback_data="subscription_status")]
        ]
        
        # Agregar botones adicionales
        keyboard.extend([
            [InlineKeyboardButton(TEXTS[lang]["policies_menu"], callback_data="policies")],
            [InlineKeyboardButton(TEXTS[lang]["contact"], callback_data="contact")],
            [InlineKeyboardButton("‚ùì Help", callback_data="help")]
        ])
        
        # Bot√≥n admin si es administrador
        if user_id in ADMIN_IDS:
            keyboard.append([InlineKeyboardButton("üîß Admin Panel", callback_data="admin_menu")])
        
        # Personalizar mensaje de bienvenida basado en estado
        subscription_status = user_status.get('status', 'never')
        if subscription_status == 'active':
            welcome_extra = "\n\n‚úÖ You have an active subscription!"
        elif subscription_status == 'churned':
            welcome_extra = "\n\n‚ö†Ô∏è Your subscription has expired. Renew to regain access!"
        else:
            welcome_extra = "\n\nüíé Ready to subscribe? Check our plans below!"
        
        text = f"{TEXTS[lang]['welcome']}\n\n{TEXTS[lang]['welcome_desc']}{welcome_extra}"
        
        await query.edit_message_text(
            text=text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Error mostrando men√∫ principal para {user_id}: {e}")
        await query.edit_message_text(
            "‚ùå Error cargando men√∫ principal.\n"
            "Usa /start para reiniciar o contacta soporte."
        )

async def show_plans(query, user_id, data):
    """Mostrar planes con informaci√≥n detallada y precios actualizados"""
    try:
        manager = await get_subscriber_manager()
        user_status = await manager.get_user_status(user_id)
        lang = user_status.get('language', 'en')
        
        keyboard = []
        
        # Ordenar planes por duraci√≥n para mejor presentaci√≥n
        sorted_plans = sorted(
            PLANS.items(), 
            key=lambda x: x[1]['duration_days']
        )
        
        for plan_id, plan_info in sorted_plans:
            channels_count = len(plan_info.get('channels', []))
            
            # Crear texto descriptivo del plan
            if plan_info['duration_days'] >= 365:
                duration_text = f"{plan_info['duration_days']//365} year(s)"
            elif plan_info['duration_days'] >= 30:
                duration_text = f"{plan_info['duration_days']//30} month(s)"
            else:
                duration_text = f"{plan_info['duration_days']} days"
            
            plan_text = f"{plan_info['name']} - {plan_info['price']}\n" \
                       f"üì∫ {channels_count} channels ‚Ä¢ ‚è±Ô∏è {duration_text}"
            
            keyboard.append([
                InlineKeyboardButton(plan_text, callback_data=f"plan_{plan_id}")
            ])
        
        keyboard.append([InlineKeyboardButton(TEXTS[lang]["back"], callback_data="main_menu")])
        
        # Texto mejorado con beneficios
        benefits_text = TEXTS[lang]['plan_benefits']
        text = f"""{TEXTS[lang]['plans_title']}

{benefits_text}

üí° **All plans include:**
‚Ä¢ Instant access after payment
‚Ä¢ High-quality exclusive content  
‚Ä¢ 24/7 customer support
‚Ä¢ Secure payment via Bold.co

Choose your perfect plan below:"""
        
        await query.edit_message_text(
            text=text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Error mostrando planes para {user_id}: {e}")
        await query.edit_message_text(
            "‚ùå Error cargando planes de suscripci√≥n.\n"
            "Por favor intenta de nuevo."
        )

async def handle_plan_selection(query, user_id, data):
    """Selecci√≥n de plan con informaci√≥n completa y seguridad mejorada"""
    try:
        manager = await get_subscriber_manager()
        user_status = await manager.get_user_status(user_id)
        lang = user_status.get('language', 'en')
        
        plan_id = data.replace("plan_", "")
        
        if plan_id not in PLANS:
            logger.warning(f"Plan inv√°lido seleccionado: {plan_id} por usuario {user_id}")
            await query.edit_message_text("‚ùå Plan no v√°lido. Por favor selecciona otro plan.")
            return
        
        plan_info = PLANS[plan_id]
        
        # Verificar si el usuario ya tiene suscripci√≥n activa
        current_status = user_status.get('status', 'never')
        if current_status == 'active':
            subscription = user_status.get('subscription')
            current_plan = subscription.get('plan') if subscription else 'Unknown'
            expires_at = subscription.get('expires_at') if subscription else None
            
            warning_text = f"\n\n‚ö†Ô∏è **Note:** You currently have an active subscription ({current_plan})"
            if expires_at:
                warning_text += f" until {expires_at.strftime('%Y-%m-%d')}"
            warning_text += ".\nThis new subscription will extend your current access."
        else:
            warning_text = ""
        
        # Descripci√≥n en el idioma correcto
        from bot.config import PLAN_DESCRIPTIONS
        description = PLAN_DESCRIPTIONS.get(lang, PLAN_DESCRIPTIONS["en"])
        
        # Informaci√≥n de canales con nombres descriptivos
        channels = plan_info.get('channels', [])
        channels_text = f"üì∫ **Channels included:** {len(channels)}\n"
        for i, channel_name in enumerate(channels, 1):
            channels_text += f"‚Ä¢ Premium Channel {i}\n"
        
        # Generar enlace de pago seguro
        from bot.config import generate_bold_link
        try:
            payment_url = generate_bold_link(
                plan_info["link_id"], 
                user_id, 
                plan_id
            )
        except Exception as e:
            logger.error(f"Error generando enlace de pago: {e}")
            await query.edit_message_text(
                "‚ùå Error generando enlace de pago.\n"
                "Por favor contacta soporte."
            )
            return
        
        # Calcular valor por d√≠a
        daily_cost = float(plan_info['price'].replace('$', '')) / plan_info['duration_days']
        
        text = f"""üíé **{plan_info['name']}**

üí∞ **Price:** {plan_info['price']} USD
‚è±Ô∏è **Duration:** {plan_info['duration_days']} days
üìä **Value:** ${daily_cost:.2f} per day

{channels_text}

**üé¨ What you get:**
{description}

{warning_text}

üîê **Secure Payment Information:**
‚Ä¢ Payment processed by Bold.co (secure & trusted)
‚Ä¢ Instant access after confirmation
‚Ä¢ User ID: `{user_id}` (for support reference)
‚Ä¢ Plan ID: `{plan_id}`

Click below to complete your secure payment:"""
        
        keyboard = [
            [InlineKeyboardButton("üí≥ Pay Securely with Bold.co", url=payment_url)],
            [InlineKeyboardButton("üîÑ Choose Different Plan", callback_data="show_plans")